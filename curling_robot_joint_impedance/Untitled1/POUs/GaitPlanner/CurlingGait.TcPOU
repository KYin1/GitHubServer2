<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.2">
  <POU Name="CurlingGait" Id="{3ea64746-c580-4f2f-ad1f-75381103e3e2}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK CurlingGait //3-3 gait for rotation
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR

	tTotal     : LREAL := 500;
	
	// robot geometrical parameters
	hip_pos : ARRAY[0..5, 0..2] OF LREAL := [-0.369,  -0.125, 0,
                                             0,  -0.28, 0,
                                             0.36, -0.125, 0,
                                             0.36, 0.125, 0,
											 0,0.28,0,
											 -0.369,0.125,0];

	leg_index_mapping : ARRAY[0..5] OF INT := [1, 2, 3, 4,5,6];
	Rleg : ARRAY[0..5] OF Mat3;
	
	gait_cycle : UDINT := 0;
	quit_flag : BOOL := FALSE;
	
	joint_ref_pos_init : ARRAY[0..5] OF Vec3;
	jointPosLast   : ARRAY[0..5, 0..2] OF LREAL; 
	
	body_ref_pos_init : Vec3;
	body_ref_ang_init : Vec3;
    leg_ref_pos_init : ARRAY[0..5] OF Vec3;
	leg_ref_pos_init_wrt_hip : ARRAY[0..5] OF Vec3;

	body_ref_pos : Vec3;
	body_ref_ang : Vec3;
	body_ref_angvel:vec3;
    leg_ref_pos : ARRAY[0..5] OF Vec3;
	leg_ref_pos_wrt_hip : ARRAY[0..5] OF Vec3;
	body_ref_pos_enter : Vec3;
	body_ref_ang_enter : Vec3;
    leg_ref_pos_enter : ARRAY[0..5] OF Vec3;
	leg_ref_pos_wrt_hip_enter : ARRAY[0..5] OF Vec3;
	
	body_ref_pos_next : Vec3;
	body_ref_ang_next : Vec3;
    leg_ref_pos_next : ARRAY[0..5] OF Vec3;
	leg_ref_pos_next_wrt_hip : ARRAY[0..5] OF Vec3;
	leg_ref_vel_next_wrt_hip : ARRAY[0..5] OF Vec3;
	
	// output test
	joint_ref_pos   : ARRAY[0..5] OF Vec3;
	joint_ref_vel   : ARRAY[0..5] OF Vec3;
	
	jointPosTarget  : ARRAY[0..5, 0..2] OF LREAL; 
	jointVelTarget  : ARRAY[0..5, 0..2] OF LREAL;  
	jointFceTarget  : ARRAY[0..5, 0..2] OF LREAL;  
	
	pvt, pvtDot : LREAL;
	
	fbRotmat : RotM;
	fbGetPivot  : GetPivot;
	delta_t:LREAL :=0.0025;//sample time
	
	isFinished : BOOL := FALSE;
	
	//target value from visual system
	adjust_angle_rad:LREAL:=0;//unit:rad
	target_vel:LREAL:=0;//unit:m/s
	stone_rot_vel:LREAL:=0;//unit:rad/s
	
	//state machine 
	 state:UINT;
	 Ready:UINT:=1;//init state
	 BodyRot:UINT:=2;// rotate body to target position
	 SearchFootHold:UINT:=3;//single searching for each back leg
	 FLegRot1:UINT:=4;//rotate front leg to horizontal plane
	 ReduceHeight:UINT:=5;//reduce heught and front knee motor rotation start
	 GripBall:UINT:=6;//grip ball and make it rotate with target velocity
	 LiftMleg:UINT:=7;// lift tips of two middle legs to reduce friction
	 SpeedUp:UINT:=8;// thrust for target body velocity
	 Slide:UINT:=9;//slide on ice ground, adjust stone rotation velocity,decide push ball velocity and position, release position 
	 PushReleaseBall:UINT:=10;//push ball acoording to reference velocity and position, release ball at the end push stroke
	 SpeedDown:UINT:=11;//speed down body velocity, front knee motor rotation stop
	 AddHeight:UINT:=12;// increase height by back and middle leg 
	 FLegRot2:UINT:=13;//rotate front leg to vertical plane
	 RecoveryReady:UINT:=14;//recovery initial position for next curling	

	 //	key time nodes
	 EnterBodyRotCount:UDINT;
	 EnterSearchFootHoldCount:UDINT;
	 EnterFLegRot1Count:UDINT;
	 EnterReduceHeightCount:UDINT;
	 EnterGripBallCount:UDINT;
	 EnterLiftMlegCount:UDINT;
	 EnterSpeedUpCount:UDINT;
	 EnterSlideCount:UDINT;
	 EnterPushReleaseBallCount:UDINT;
	 EnterSpeedDownCount:UDINT;
	 EnterAddHeightCount:UDINT;
	 EnterFLegRot2Count:UDINT;
	 EnterRecoveryReadyCount:UDINT;
	 
	 // contrl button
	 requireBodyRot:BOOL:=FALSE;
	 requireSearchFootHold:BOOL:=FALSE;
	 requireFLegRot1:BOOL:=FALSE;
	 requireReduceHeight:BOOL:=FALSE;
	 requireGripBall:BOOL:=FALSE;
	 requireLiftMleg:BOOL:=FALSE;
	 requireSpeedUp:BOOL:=FALSE;
	 requireSlide:BOOL:=FALSE;
	 requirePushReleaseBall:BOOL:=FALSE;
	 requireSpeedDown:BOOL:=FALSE;
	 requireAddHeight:BOOL:=FALSE;
	 requireFLegRot2:BOOL:=FALSE;
	 requireRecoveryReady:BOOL:=FALSE;
	 
	 // common variables
	 fbElipseInterpolation:ElipseInterpolation;
	 fbHermitInterpolation:HermitInterpolation;
	 LegMapping14:ARRAY[0..1] OF INT:=[1,4];
	 LegMapping05:ARRAY[0..1] OF INT:=[0,5];
	 LegMapping23:ARRAY[0..1] OF INT:=[2,3];
	 
	 
	 // BodyRot variables
	 period_half_bodyRot:LREAL:=2;
	 BodyRotTotalCount:DINT:=4000;
	 H_step:LREAL:=0.05;
	 period_count :UDINT := 0;
	 BodyRotFinished:BOOL:=FALSE;
	 
	 
	 // SearchFootHold variables
	 lift_time:LREAL:=0.5;// time for lifting back leg in vertical direction
	 lift_distance:LREAL:=0.025;// distance for lifting back leg in vertical direction
	 search_time:LREAL:=10;//time for searching pedal
	 search_distance:LREAL:=0.1;//distance for searching pedal
	 down_time:LREAL:=0.5;// time for lifting back leg in vertical direction
	 down_distance:LREAL:=0.025;// distance for lifting back leg in vertical direction
	 holdTime:LREAL:=3;// switch time from leg 0 to leg 5
	 SearchFootHoldFinished:BOOL:=FALSE;
	 
 	 searchedPedal:ARRAY [0..1] OF BOOL:=[FALSE,FALSE];
	 SearchFootHoldSubState:ARRAY [0..1] OF UINT:=[1,1];
	 ReadySearchState:UINT:=1;
	 LiftLegState:UINT:=2;
	 SearchPedalState:UINT:=3;
	 DownLegState:UINT:=4;
	 PreSearchedState:UINT:=5;
	 SearchedState:UINT:=6;
	 
	 requireLiftLegButton:ARRAY[0..1] OF BOOL:=[TRUE,TRUE];
	 EnterLiftLegStateCount:ARRAY[0..1] OF UDINT;
	 EnterSearchPedalStateCount:ARRAY[0..1] OF UDINT;
	 EnterDownLegStateCount:ARRAY[0..1] OF UDINT;
	 EnterSearchedStateCount:ARRAY[0..1] OF UDINT;
	 EnterPreSearchedStateCount:ARRAY[0..1] OF UDINT;
	 
	 tipSearchStartPosWrtHip:ARRAY[0..1] OF vec3;
	 tipSearchEndPosWrtHip:ARRAY[0..1] OF vec3;
	 tipSearchPosWrtHip:ARRAY[0..1] OF vec3;
	 
	 tipDownLegPosWrtHip:ARRAY[0..1] OF vec3;
	 tipDownLegStartPosWrtHip:ARRAY[0..1] OF vec3;
	 tipDownLegEndPosWrtHip:ARRAY[0..1] OF vec3;
	 
	 // FLegRot1 variables
	 leg2_start_joint_angle:vec3;
	 leg2_joint_angle:vec3;
	 leg3_start_joint_angle:vec3;
	 leg3_joint_angle:vec3;
	 leg2_pos_wrt_hip:vec3;
	 leg3_pos_wrt_hip:vec3;
	 FLegRot1Time:LREAL:=2;//duration time for angle change
	 FLegRot1Finished:BOOL:=FALSE;
	 
	 //Reduce height variables
	 ReduceHeightTime:LREAL:=5;
	 targetHeight:LREAL:=0.2256;//need be calibrated
	 body_target_pos:vec3;
	 leg2_start_reduce_height_joint_angle:vec3;
	 leg3_start_reduce_height_joint_angle:vec3;
	 leg2_start_reduce_height_pos_wrt_hip:vec3;
	 leg3_start_reduce_height_pos_wrt_hip:vec3;
	 ReduceHeightFinished:BOOL:=FALSE;
	 
	 //Grip ball
	 GripBallTime:LREAL:=5;
	 leg_start_grip_ball_joint_angle:ARRAY[0..1] OF vec3;
	 leg_grip_ball_joint_angle:ARRAY[0..1] OF vec3;
	 leg_grip_ball_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 GripBallSubState:ARRAY [0..1] OF BOOL:=[FALSE,FALSE];
	 GripBallFinished:BOOL:=FALSE;
	 
	 //LiftMleg
	 LiftMlegTime:LREAL:=2;
	 leg_start_lift_Mleg_joint_angle:ARRAY[0..1] OF vec3;
	 leg_lift_Mleg_joint_angle:ARRAY[0..1] OF vec3;
	 leg_lift_Mleg_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 LiftMlegFinished:BOOL:=FALSE;
	 
	 //SpeedUp
	 leg_speed_up_start_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 leg_speed_up_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 leg_speed_up_end_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 
	 SpeedUpSubState:UINT:=0;
	 SpeedUpAS:UINT:=1;//acceleration
	 SpeedUpCS:UINT:=2;//constant velocity
	 SpeedUpDS:UINT:=3;//deceleration velocity
	 SpeedUpSS:UINT:=4;//stop
	 
	 Distance_x_AS:LREAL:=0.3;// acceleration distance in x direction
	 Distance_x_DS:LREAL:=0.15;// deceleration distance in x direction
	 Distance_y_DS:LREAL:=0.15;// deceleration distance in y direction
	 Time_AS:LREAL:=0.3;//acceleration time
	 Time_CS:LREAL:=0.05;//constant time
	 Time_DS:LREAL:=0.2;//deceleration time
	 
	 EnterSpeedUpASCount:UDINT;
	 EnterSpeedUpCSCount:UDINT;
	 EnterSpeedUpDSCount:UDINT;
	 EnterSpeedUpSPCount:UDINT;
	 
	 SpeedUpFinished:BOOL:=FALSE;
	 
	 //slide
	 SlideFinished:BOOL:=FALSE;
	 ReleaseBallPositionReached:BOOL:=FALSE;
	 SlideTime:LREAL:=1.5;
	 
	 //PushReleaseBall
	 PushReleaseBallFinished:BOOL:=FALSE;
	 PushReleaseBallTime:LREAL:=0.25;
	 FlegPushReleaseBall_start_joint_angle:ARRAY[0..1]OF vec3;
	 FlegPushReleaseBall_joint_angle:ARRAY[0..1]OF vec3;
	 FlegPushReleaseBall_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 
	 //speed down
	 SpeedDownTime:LREAL:=3;
	 Mleg_speed_down_start_joint_angle:ARRAY[0..1]OF vec3;
	 Mleg_speed_down_joint_angle:ARRAY[0..1]OF vec3;
	 Mleg_speed_down_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 Bleg_speed_down_start_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 Bleg_speed_down_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 Mleg_speed_down_finished:ARRAY[0..1] OF BOOL:=[FALSE,FALSE];
	 Bleg_speed_down_finished:ARRAY[0..1] OF BOOL:=[FALSE,FALSE];
	 SpeedDownFinished:BOOL:=FALSE;
	 visual_tested_velocity:LREAL:=0;
	 
	 //Add height
	 sum_height : LREAL := 0;
	 Fleg_add_height_start_joint_angle:ARRAY[0..1]OF vec3;
	 Fleg_add_height_pos_wrt_hip:ARRAY[0..1] OF vec3;
	 AddHeightTime:LREAL:=5;
	 AddHeightFinished:BOOL:=FALSE;
	 
	 //FlegRot2
	 FlegRot2Time:LREAL:=2;
	 Fleg_FlegRot2_start_joint_angle:ARRAY[0..1]OF vec3;
	 Fleg_FlegRot2_pos_wrt_hip:ARRAY[0..1] OF vec3;	 
	 FlegRot2Finished:BOOL:=FALSE;
	 
	 //RecoveryReady
	 RecoveryReadyFinished:BOOL:=FALSE;
	tRetract   : LREAL := 3;
	tWait      : LREAL := 1;
	tExtend    : LREAL := 3;
	jntAngStart:ARRAY[0..5,0..2] OF LREAL;

	pivot, pivotDot : LREAL;
	getPivot  : GetPivot;	

	(*jointPosTarget  : ARRAY[0..5, 0..2] OF LREAL; 
	jointVelTarget  : ARRAY[0..5, 0..2] OF LREAL;  
	jointFceTarget  : ARRAY[0..5, 0..2] OF LREAL;	*)
	 
END_VAR
















]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="DoPlanning" Id="{7be0e9b2-e30a-449c-a5f2-b17ff15db0d8}">
      <Declaration><![CDATA[METHOD PUBLIC DoPlanning : BOOL
VAR_INPUT
	count : UDINT;
END_VAR
VAR
	i, j  : INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF count = 0 THEN
	isFinished := FALSE;
	Initialize();
END_IF
StateMachine();
TrjPlanning();

IF quit_flag THEN
	isFinished := TRUE;
	quit_flag := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Initialize" Id="{2636f6c7-bead-4d7f-a0c4-5145c929a830}">
      <Declaration><![CDATA[METHOD PUBLIC Initialize : BOOL
VAR_INPUT
END_VAR
VAR
	i, j : INT;
	
	leg_pos    : ARRAY[0..2] OF LREAL;
	
	Rb : Mat3;
	hip_pos_j  : Vec3;
	leg_pos_wrt_com : Vec3;
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Rleg[0]:=SetMat3(1,0,0,0,0,-1,0,1,0);
Rleg[1]:=SetMat3(-1,0,0,0,0,1,0,1,0,);
Rleg[2]:=SetMat3(-1,0,0,0,0,1,0,1,0);
Rleg[3]:=SetMat3(-1,0,0,0,0,1,0,1,0);
Rleg[4]:=SetMat3( -1,0,0,0,0,1,0,1,0);
Rleg[5]:=SetMat3(1,0,0,0,0,-1,0,1,0);

state:=Ready;
quit_flag  := FALSE;
gait_cycle := 0;

// control button for each state, need be commented out at actual environment
requireBodyRot:=TRUE;
requireSearchFootHold:=TRUE;
requireFLegRot1:=TRUE;
requireReduceHeight:=TRUE;
requireGripBall:=TRUE;
requireLiftMleg:=TRUE;
requireSpeedUp:=TRUE;
requireSlide:=TRUE;
requirePushReleaseBall:=TRUE;
requireSpeedDown:=TRUE;
requireAddHeight:=TRUE;
requireFLegRot2:=TRUE;
requireRecoveryReady:=TRUE;

BodyRotFinished:=FALSE;
SearchFootHoldFinished:=FALSE;
FLegRot1Finished:=FALSE;
ReduceHeightFinished:=FALSE;
GripBallFinished:=FALSE;
LiftMlegFinished:=FALSE;
SpeedUpFinished:=FALSE;
SlideFinished:=FALSE;
PushReleaseBallFinished:=FALSE;
SpeedDownFinished:=FALSE;
AddHeightFinished:=FALSE;
FLegRot2Finished:=FALSE;
RecoveryReadyFinished:=FALSE;

// bodyRot
BodyRotTotalCount:=TRUNC(gvl.sampleRate*period_half_bodyRot);
delta_t:=1.0/gvl.SampleRate;//sample time
// SearchFootHold
searchedPedal[0]:=FALSE;
searchedPedal[1]:=FALSE;
//GripBall
GripBallSubState[0]:=FALSE;
GripBallSubState[1]:=FALSE;

FOR i := 0 TO 5 DO
	FOR j := 0 TO 2 DO
		joint_ref_pos_init[i].data[j] := gvl.jntActualPos[i, j];
		jointPosLast[i,j]:=joint_ref_pos_init[i].data[j];
	END_FOR
END_FOR

sum_height := 0;
FOR j := 0 TO 5 DO
	// FK
	gvl.legCtrl[j].ForwardKinetics(motorAngles := joint_ref_pos_init[j].data, legIndex:=j, tipPosition => leg_pos);
	leg_ref_pos_init_wrt_hip[j] := SetVec3(leg_pos[0], leg_pos[1], leg_pos[2]);
	sum_height := sum_height - leg_ref_pos_init_wrt_hip[j].data[1];
END_FOR
body_ref_pos_init := SetVec3(0, 0, sum_height/6.0);
body_ref_ang_init := SetVec3(0, 0, 0);                            

FOR j := 0 TO 5 DO
	fbRotMat(yaw := body_ref_ang_init.data[2],
             pitch := body_ref_ang_init.data[1],
             roll := body_ref_ang_init.data[0],
             rm => Rb );
	hip_pos_j := SetVec3(hip_pos[j, 0], hip_pos[j, 1], hip_pos[j, 2]);
	leg_pos_wrt_com := VecAdd(MatMulVec(Rleg[j], leg_ref_pos_init_wrt_hip[j]), hip_pos_j);
    leg_ref_pos_init[j] := VecAdd(body_ref_pos_init, MatMulVec(Rb, leg_pos_wrt_com));
END_FOR

body_ref_pos := body_ref_pos_init;
body_ref_ang := body_ref_ang_init;
leg_ref_pos := leg_ref_pos_init;
leg_ref_pos_wrt_hip := leg_ref_pos_init_wrt_hip;

FOR i := 0 TO 5 DO
	FOR j := 0 TO 2 DO
		jointPosTarget[i, j] := joint_ref_pos_init[i].data[j];
		jointVelTarget[i, j] := 0;
		jointFceTarget[i, j] := 0;
	END_FOR
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="isGrounded" Id="{3359cca6-0c22-4be4-bd8f-31894e24241f}">
      <Declaration><![CDATA[METHOD PUBLIC isGrounded : BOOL
VAR_INPUT
	legIndex:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ABS(gvl.tipActualFce[legIndex,1])>10 THEN
	isGrounded:=TRUE;
ELSE
	isGrounded:=FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="isPedal" Id="{f5f74937-f774-42ed-949f-f7280b79898b}">
      <Declaration><![CDATA[METHOD PUBLIC isPedal : BOOL
VAR_INPUT
	legIndex:int;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ABS(gvl.tipActualFce[legIndex,0])>10 THEN
	isPedal:=TRUE;
ELSE
	isPedal:=FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="isStone" Id="{4fc656a3-cc0d-406f-a9ca-2136debd7122}">
      <Declaration><![CDATA[METHOD PUBLIC isStone : BOOL
VAR_INPUT
	legIndex:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ABS(gvl.tipActualFce[legIndex,2])>10 THEN
	isStone:=TRUE;
ELSE
	isStone:=FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetTargetValue" Id="{59f44d5c-922a-472c-a7ad-c794f3386405}">
      <Declaration><![CDATA[METHOD PUBLIC SetTargetValue : BOOL
VAR_INPUT
	in_adjust_angle_degree:LREAL:=0;//unit:degree
	in_target_vel:LREAL:=0;//unit:m/s
	in_stone_rot_vel:LREAL:=0;//unit:rpm
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[adjust_angle_rad:=in_adjust_angle_degree*pi/180;
target_vel:=in_target_vel;
stone_rot_vel:=in_stone_rot_vel/60*2*pi;]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{40c9c307-427c-4b7a-a672-8b954046a8dd}">
      <Declaration><![CDATA[METHOD StateMachine : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	j: INT;
	temp:array[0..2] of lreal;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF  state=Ready AND requireBodyRot=TRUE THEN
	state:=BodyRot;
	requireBodyRot:=FALSE;
	body_ref_pos_enter := body_ref_pos_init;
	body_ref_ang_enter := body_ref_ang_init;
	leg_ref_pos_enter := leg_ref_pos_init;
	EnterBodyRotCount:=gait_cycle;
ELSIF state=BodyRot AND BodyRotFinished=TRUE AND requireSearchFootHold=TRUE THEN
	state:=SearchFootHold;
	requireSearchFootHold:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterSearchFootHoldCount:=gait_cycle;
	
ELSIF state=SearchFootHold AND SearchFootHoldFinished=TRUE AND requireFLegRot1=TRUE THEN
	state:=FLegRot1;
	requireFLegRot1:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterFLegRot1Count:=gait_cycle;
	FOR i:=0 TO 2 DO
		leg2_start_joint_angle.data[i]:=jointPosLast[2,i];
		leg3_start_joint_angle.data[i]:=jointPosLast[3,i];
	END_FOR
ELSIF state=FLegRot1 AND FLegRot1Finished=TRUE AND requireReduceHeight=TRUE THEN
	state:=ReduceHeight;
	requireReduceHeight:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterReduceHeightCount:=gait_cycle;
	
	body_target_pos:=body_ref_pos_enter;
	body_target_pos.data[2]:=targetHeight;
	FOR i:=0 TO 2 DO
		leg2_start_reduce_height_joint_angle.data[i]:=jointPosLast[2,i];
		leg3_start_reduce_height_joint_angle.data[i]:=jointPosLast[3,i];
	END_FOR
ELSIF state=ReduceHeight AND ReduceHeightFinished=TRUE AND requireGripBall=TRUE THEN
	state:=GripBall;
	requireGripBall:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterGripBallCount:=gait_cycle;
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			leg_start_grip_ball_joint_angle[i].data[j]:=jointPosLast[i+2,j];
		END_FOR
	END_FOR
ELSIF state=GripBall AND GripBallFinished=TRUE AND requireLiftMleg=TRUE THEN
    state:=LiftMleg;
	requireLiftMleg:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterLiftMlegCount:=gait_cycle;
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			leg_start_lift_Mleg_joint_angle[i].data[j]:=jointPosLast[LegMapping14[i],j];
		END_FOR
	END_FOR
ELSIF state=LiftMleg AND LiftMlegFinished=TRUE AND requireSpeedUp=TRUE THEN
    state:=SpeedUp;
	requireSpeedUp:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterSpeedUpCount:=gait_cycle;	
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			temp[j]:=jointPosLast[LegMapping05[i],j];
		END_FOR
		gvl.legCtrl[LegMapping05[i]].ForwardKinetics(motorAngles:=temp , legIndex:=LegMapping05[i] , tipPosition=>leg_speed_up_start_pos_wrt_hip[i].data );
	END_FOR	
	SpeedUpSubState:=SpeedUpAS;
	EnterSpeedUpASCount:=gait_cycle;
ELSIF state=SpeedUp AND SpeedUpFinished=TRUE AND  requireSlide=TRUE THEN
	state:=Slide;
	requireSlide:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterSlideCount:=gait_cycle;
ELSIF state=Slide AND SlideFinished=TRUE AND requirePushReleaseBall=TRUE THEN
	state:=PushReleaseBall;
	requirePushReleaseBall:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterPushReleaseBallCount:=gait_cycle;
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO			
			FlegPushReleaseBall_start_joint_angle[i].data[j]:=jointPosLast[LegMapping23[i],j];
		END_FOR
	END_FOR
	
	
ELSIF state=PushReleaseBall AND PushReleaseBallFinished=TRUE AND requireSpeedDown=TRUE THEN
	state:=SpeedDown;
	requireSpeedDown:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterSpeedDownCount:=gait_cycle;
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			Mleg_speed_down_start_joint_angle[i].data[j]:=jointPosLast[LegMapping14[i],j];
			temp[j]:=jointPosLast[LegMapping05[i],j];
		END_FOR	
		gvl.legCtrl[LegMapping05[i]].ForwardKinetics(motorAngles:=temp , legIndex:=LegMapping05[i] , tipPosition=>Bleg_speed_down_start_pos_wrt_hip[i].data );	
	END_FOR
	
ELSIF state=SpeedDown AND SpeedDownFinished=TRUE AND requireAddHeight=TRUE THEN
	state:=AddHeight;
	requireAddHeight:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterAddHeightCount:=gait_cycle;
	
	body_target_pos:=body_ref_pos_enter;
	body_target_pos.data[2]:=sum_height/6.0;
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			Fleg_add_height_start_joint_angle[i].data[j]:=jointPosLast[LegMapping23[i],j];
		END_FOR
	END_FOR
ELSIF state=AddHeight AND AddHeightFinished=TRUE AND requireFLegRot2=TRUE THEN
	state:=FLegRot2;
	requireFLegRot2:=FALSE;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	EnterFLegRot2Count:=gait_cycle;
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			Fleg_FlegRot2_start_joint_angle[i].data[j]:=jointPosLast[LegMapping23[i],j];
		END_FOR
	END_FOR
	
	
END_IF















 ]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning" Id="{c6baec29-70d5-4a48-a08a-25032f736463}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning : BOOL
VAR_INPUT
END_VAR
VAR
	tr : LREAL;
	i, j : INT;
	Rb : Mat3;
	hip_pos_j : Vec3;
	leg_ref_pos_wrt_com_j : Vec3;
	tmp : Vec3;
	tip_pos, tip_vel : Vec3;
	
	body_ref_pos_start : Vec3;
	body_ref_pos_end : Vec3;
	jointTmpPosLast: ARRAY[0..2] OF LREAL;
	body_ref_ang_start: Vec3;
	leg_ref_pos_start: ARRAY [0..5] OF Vec3;
	leg_ref_pos_target: ARRAY [0..5] OF Vec3;
	body_ref_ang_end: Vec3;
	Rb_target2: Mat3;
	Rb_target1: Mat3;
	leg_ref_pos_end: ARRAY [0..5] OF Vec3;
	fbElipseInterpolation:ElipseInterpolation;
	fbHermitInterpolation:HermitInterpolation;
	holdPos: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[gait_cycle := gait_cycle + 1;

IF state=BodyRot THEN
	TrjPlanning_BodyRot();
ELSIF state=SearchFootHold THEN
	TrjPlanning_SearchFootHold();
ELSIF state=FLegRot1 THEN
	TrjPlanning_FLegRot1();
ELSIF state=ReduceHeight THEN
	TrjPlanning_ReduceHeight();
ELSIF state=GripBall THEN
	TrjPlanning_GripBall();
ELSIF state=LiftMleg THEN
	TrjPlanning_LiftMleg();
ELSIF state=SpeedUp THEN	
	TrjPlanning_SpeedUp();
ELSIF state=Slide THEN
	TrjPlanning_Slide();
ELSIF state=PushReleaseBall THEN
	TrjPlanning_PushReleaseBall();
ELSIF state=SpeedDown THEN
	TrjPlanning_SpeedDown();
ELSIF state=AddHeight THEN	
	TrjPlanning_AddHeight();
ELSIF state=FLegRot2 THEN
	TrjPlanning_FLegRot2();
ELSIF state=RecoveryReady THEN	
	TrjPlanning_RecoveryReady();
END_IF

// transform TO leg local frame AND DO inverse kinematics

FOR j := 0 TO 5 DO
	fbRotMat(
    	yaw := body_ref_ang.data[2], 
		pitch := body_ref_ang.data[1], 
		roll := body_ref_ang.data[0], 
		rm => Rb);
	hip_pos_j := SetVec3(hip_pos[j, 0], hip_pos[j, 1], hip_pos[j, 2]);

	//leg_ref_pos_wrt_com = Rb' * (leg_ref_pos - body_ref_pos)
	leg_ref_pos_wrt_com_j := MatMulVec(
		                         MatTranspose(Rb),
								 VecAdd(
									 leg_ref_pos[j],
									 VecNeg(body_ref_pos)
                                 )
                             );
	// leg_ref_pos_wrt_hip = Rleg' * (leg_ref_pos_wrt_com_j - hip_pos)
	leg_ref_pos_next_wrt_hip[j] := MatMulVec(
		                               MatTranspose(Rleg[j]),
									   VecAdd(
										   leg_ref_pos_wrt_com_j,
										   VecNeg(hip_pos_j)
									   )
								   );
								   
	leg_ref_vel_next_wrt_hip[j] := VecMulNum(VecAdd(leg_ref_pos_next_wrt_hip[j], VecNeg(leg_ref_pos_wrt_hip[j])), DINT_TO_LREAL(gvl.sampleRate));
END_FOR


// mapping to actual joints
FOR j := 0 TO 5 DO
	tmp := leg_ref_pos_next_wrt_hip[leg_index_mapping[j]-1];
	tip_pos := SetVec3(tmp.data[0], tmp.data[1], tmp.data[2]);
	tmp := leg_ref_vel_next_wrt_hip[leg_index_mapping[j]-1];
	tip_vel := SetVec3(tmp.data[0], tmp.data[1], tmp.data[2]);
	FOR i:= 0 TO 2 DO
		jointTmpPosLast[i]:=jointPosLast[j,i];
	END_FOR		
	gvl.legCtrl[j].InversePosAndVel(
		tipPos := tip_pos.data, 
		tipVel := tip_vel.data, 
		refPosLast:=jointTmpPosLast,
		legIndex:=j,
		jntPos => joint_ref_pos[j].data, 
		jntVel => joint_ref_vel[j].data);
	
END_FOR

// link to physical outputs
FOR i := 0 TO 5 DO
	FOR j := 0 TO 2 DO
		jointPosTarget[i, j] := joint_ref_pos[i].data[j];
		jointPosLast[i,j]:=jointPosTarget[i, j] ;
		gvl.jntRefPosLastPlanning[i,j]:=jointPosTarget[i, j] ;
		jointVelTarget[i, j] := joint_ref_vel[i].data[j];
		jointFceTarget[i, j] := 0;
	END_FOR
END_FOR

// store refs for next loop
leg_ref_pos_wrt_hip := leg_ref_pos_next_wrt_hip;

IF gait_cycle > tTotal * gvl.sampleRate THEN
	quit_flag := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_AddHeight" Id="{c6792835-e371-46ea-a695-7ba2499c3d5b}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_AddHeight : BOOL
VAR_INPUT
END_VAR

VAR
	tr: LREAL;
	i: INT;
	Rb_target1: Mat3;
	temp:vec3;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF  AddHeightFinished=FALSE AND (gait_cycle-EnterAddHeightCount)<=AddHeightTime*gvl.sampleRate THEN
	body_ref_ang:=body_ref_ang_enter;
	leg_ref_pos:=leg_ref_pos_enter;
	tr  := UDINT_TO_LREAL(gait_cycle - EnterAddHeightCount) / gvl.sampleRate / AddHeightTime;
	fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
	FOR i:=0 TO 2 DO
		body_ref_pos.data[i]:=(1-pvt)*body_ref_pos_enter.data[i]+pvt*body_target_pos.data[i];
	END_FOR
	
	FOR i:=0 TO 1 DO
		gvl.legCtrl[LegMapping23[i]].ForwardKinetics(motorAngles:=Fleg_add_height_start_joint_angle[i].data , legIndex:=LegMapping23[i] , tipPosition=>Fleg_add_height_pos_wrt_hip[i].data );
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm => Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping23[i],0];temp.data[1]:=hip_pos[LegMapping23[i],1];temp.data[2]:=hip_pos[LegMapping23[i],2];
		leg_ref_pos[LegMapping23[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping23[i]],Fleg_add_height_pos_wrt_hip[i]))),body_ref_pos);
	END_FOR
ELSE
	AddHeightFinished:=TRUE;	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_BodyRot" Id="{3dfdfc90-40a3-48d3-997b-ee5ab36341ce}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_BodyRot : BOOL
VAR_INPUT
END_VAR
VAR
	tr : LREAL;
	i, j : INT;
	Rb : Mat3;
	hip_pos_j : Vec3;
	leg_ref_pos_wrt_com_j : Vec3;
	tmp : Vec3;
	tip_pos, tip_vel : Vec3;
	
	body_ref_pos_start : Vec3;
	body_ref_pos_end : Vec3;
	jointTmpPosLast: ARRAY[0..2] OF LREAL;
	body_ref_ang_start: Vec3;
	leg_ref_pos_start: ARRAY [0..5] OF Vec3;
	leg_ref_pos_target: ARRAY [0..5] OF Vec3;
	body_ref_ang_end: Vec3;
	Rb_target2: Mat3;
	Rb_target1: Mat3;
	leg_ref_pos_end: ARRAY [0..5] OF Vec3;

	holdPos: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF state=BodyRot AND BodyRotFinished=FALSE AND gait_cycle-EnterBodyRotCount<=2*BodyRotTotalCount THEN
	period_count:=(gait_cycle-EnterBodyRotCount) MOD BodyRotTotalCount;
	fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
	fbRotMat(yaw :=  body_ref_ang_enter.data[2]+adjust_angle_rad, pitch := 0,roll := 0,rm => Rb_target2);
	FOR i:=0 TO 5 DO
		leg_ref_pos_target[i]:=VecAdd(MatMulVec(Rb_target2, MatMulVec(MatTranspose(Rb_target1), VecAdd(leg_ref_pos_enter[i],VecNeg(body_ref_pos_enter)))),body_ref_pos_enter);
	END_FOR
	
	IF gait_cycle-EnterBodyRotCount<=BodyRotTotalCount THEN //0-2-4stance, 1-3-5 swing
		body_ref_pos_start:=body_ref_pos_enter;
		body_ref_ang_start:=body_ref_ang_enter;
		leg_ref_pos_start:=leg_ref_pos_enter;
		
		body_ref_pos_end:=body_ref_pos_enter;
		body_ref_ang_end:=body_ref_ang_enter;
		body_ref_ang_end.data[2]:=body_ref_ang_enter.data[2]+adjust_angle_rad/2.0;
		FOR i:=1 TO 5 BY 2 DO
			leg_ref_pos_end[i]:=leg_ref_pos_target[i];
			leg_ref_pos_end[i-1]:=leg_ref_pos_start[i-1];
		END_FOR
		// planing toe trajectory
		FOR i:=0 TO 5 BY 2 DO
			leg_ref_pos[i]:=leg_ref_pos_start[i];//0-2-4 stance
			fbElipseInterpolation(x0:=leg_ref_pos_start[i+1].data[0] , y0:=leg_ref_pos_start[i+1].data[1] , z0:=leg_ref_pos_start[i+1].data[2] , x1:=leg_ref_pos_end[i+1].data[0] , 
			y1:=leg_ref_pos_end[i+1].data[1] , z1:=leg_ref_pos_end[i+1].data[2] , h:=H_step , T:=BodyRotTotalCount*delta_t , t0:=0 , tNow:= period_count*delta_t, 
			x=>leg_ref_pos[i+1].data[0] , y=>leg_ref_pos[i+1].data[1] , z=>leg_ref_pos[i+1].data[2] );
		END_FOR
		// planing body trajectory
		body_ref_pos:=body_ref_pos_start;
		FOR i:=0 TO 2 DO
			fbHermitInterpolation(t0:=0 , T:=BodyRotTotalCount*delta_t , y0:=body_ref_ang_start.data[i] , y1:=body_ref_ang_end.data[i] , v0:=0 , 
			v1:=0 , tNow:=period_count*delta_t , y=>body_ref_ang.data[i] , v=> body_ref_angvel.data[i]);		
		END_FOR
		
	ELSIF gait_cycle-EnterBodyRotCount>BodyRotTotalCount AND gait_cycle-EnterBodyRotCount<=BodyRotTotalCount THEN //0-2-4swing, 1-3-5 stance
		FOR i:=1 TO 5 BY 2 DO
			leg_ref_pos_start[i]:=leg_ref_pos_target[i];
			leg_ref_pos_end[i]:=leg_ref_pos_target[i];
			leg_ref_pos_start[i-1]:=leg_ref_pos_enter[i-1];
			leg_ref_pos_end[i-1]:=leg_ref_pos_target[i-1];
		END_FOR		
		body_ref_ang_start.data[0]:=body_ref_ang_enter.data[0];
		body_ref_ang_start.data[1]:=body_ref_ang_enter.data[1];
		body_ref_ang_start.data[2]:=body_ref_ang_enter.data[2]+adjust_angle_rad/2.0;
		body_ref_ang_end.data[0]:=body_ref_ang_enter.data[0];
		body_ref_ang_end.data[1]:=body_ref_ang_enter.data[1];
		body_ref_ang_end.data[2]:=body_ref_ang_enter.data[2]+adjust_angle_rad;
		// planing toe trajectory
		FOR i:=0 TO 5 BY 2 DO
			leg_ref_pos[i+1]:=leg_ref_pos_start[i+1];//1-3-5 stance
			fbElipseInterpolation(x0:=leg_ref_pos_start[i].data[0] , y0:=leg_ref_pos_start[i].data[1] , z0:=leg_ref_pos_start[i].data[2] , x1:=leg_ref_pos_end[i].data[0] , 
			y1:=leg_ref_pos_end[i].data[1] , z1:=leg_ref_pos_end[i].data[2] , h:=H_step , T:=BodyRotTotalCount*delta_t , t0:=0 , tNow:= period_count*delta_t, 
			x=>leg_ref_pos[i].data[0] , y=>leg_ref_pos[i].data[1] , z=>leg_ref_pos[i].data[2] );//0-2-4 swing
		END_FOR
		// planing body trajectory
		body_ref_pos:=body_ref_pos_enter;
		FOR i:=0 TO 2 DO
			fbHermitInterpolation(t0:=0 , T:=BodyRotTotalCount*delta_t , y0:=body_ref_ang_start.data[i] , y1:=body_ref_ang_end.data[i] , v0:=0 , 
			v1:=0 , tNow:=period_count*delta_t , y=>body_ref_ang.data[i] , v=> body_ref_angvel.data[i]);		
		END_FOR		
		
	ELSE
		holdPos:=1;	
	END_IF
ELSE	
	BodyRotFinished:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_FLegRot1" Id="{34c633aa-e51b-407c-8760-c44757ce5258}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_FLegRot1 : BOOL
VAR_INPUT
END_VAR
VAR
	leg2_target_joint_angle:ARRAY[0..2] OF LREAL:=[-pi/2,165*pi/180,(350-165)*pi/180];
	leg3_target_joint_angle:ARRAY[0..2] OF LREAL:=[pi/2,165*pi/180,(350-165)*pi/180];
	tr: LREAL;
	i: INT;
	Rb_target1: Mat3;
	temp:vec3;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF FLegRot1Finished=FALSE AND (gait_cycle-EnterFLegRot1Count)<=FLegRot1Time*gvl.sampleRate THEN
	body_ref_pos:=body_ref_pos_enter;
	body_ref_ang:=body_ref_ang_enter;
	leg_ref_pos:=leg_ref_pos_enter;
	
	tr  := UDINT_TO_LREAL(gait_cycle - EnterFLegRot1Count) / gvl.sampleRate / FLegRot1Time;
	fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
	FOR i:=0 TO 2 DO
		leg2_joint_angle.data[i]:=(1-pvt)*leg2_start_joint_angle.data[i]+pvt*leg2_target_joint_angle[i];
		leg3_joint_angle.data[i]:=(1-pvt)*leg3_start_joint_angle.data[i]+pvt*leg3_target_joint_angle[i];
	END_FOR
	gvl.legCtrl[2].ForwardKinetics(motorAngles:=leg2_joint_angle.data , legIndex:=2 , tipPosition=>leg2_pos_wrt_hip.data );
	gvl.legCtrl[3].ForwardKinetics(motorAngles:=leg3_joint_angle.data , legIndex:=3 , tipPosition=>leg3_pos_wrt_hip.data );
	
	fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
	temp.data[0]:=hip_pos[2,0];temp.data[1]:=hip_pos[2,1];temp.data[2]:=hip_pos[2,2];
	leg_ref_pos[2]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[2],leg2_pos_wrt_hip))),body_ref_pos);
	temp.data[0]:=hip_pos[3,0];temp.data[1]:=hip_pos[3,1];temp.data[2]:=hip_pos[3,2];
	leg_ref_pos[3]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[3],leg3_pos_wrt_hip))),body_ref_pos);
	
	// drive knee motor with target velocity
	GVL.jogVelocity[18]:=stone_rot_vel;
	GVL.jogVelocity[19]:=-stone_rot_vel;
	FOR i:=18 TO 19 DO
		IF gvl.motorDrive[i].cvSetVel =GVL.jogVelocity[i] THEN
			gvl.jogButton[i]:=FALSE;
		ELSE
			gvl.jogButton[i]:=TRUE;
		END_IF
	END_FOR
	
ELSE
	FLegRot1Finished:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_FLegRot2" Id="{1a411567-d6d7-4790-8ec4-21b13a6e8556}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_FLegRot2 : BOOL
VAR_INPUT
END_VAR

VAR
	tr: LREAL;
	leg_target_joint_angle:ARRAY[0..1,0..2] OF LREAL:=[0,168*pi/180,(350-168)*pi/180,
                                                       0,168*pi/180,(350-168)*pi/180];//need be calibrated to RC joint angle
	i: INT;
	j: INT;
	Rb_target1: Mat3;
	temp:vec3;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (gait_cycle-EnterFLegRot2Count)<=FLegRot2Time*gvl.sampleRate THEN
	body_ref_pos:=body_ref_pos_enter;
	body_ref_ang:=body_ref_ang_enter;
	leg_ref_pos:=leg_ref_pos_enter;	
	
	tr  := UDINT_TO_LREAL(gait_cycle - EnterFLegRot2Count) / gvl.sampleRate / FLegRot2Time;
	fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			Fleg_FlegRot2_pos_wrt_hip[i].data[j]:=(1-pvt)*Fleg_FlegRot2_start_joint_angle[i].data[j]+pvt*leg_target_joint_angle[i,j];
		END_FOR
		gvl.legCtrl[LegMapping23[i]].ForwardKinetics(motorAngles:=Fleg_FlegRot2_pos_wrt_hip[i].data , legIndex:=LegMapping23[i] , tipPosition=>Fleg_FlegRot2_pos_wrt_hip[i].data );
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm => Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping23[i],0];temp.data[1]:=hip_pos[LegMapping23[i],1];temp.data[2]:=hip_pos[LegMapping23[i],2];
		leg_ref_pos[LegMapping23[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping23[i]],Fleg_FlegRot2_pos_wrt_hip[i]))),body_ref_pos);
	END_FOR
	
	// drive knee motor with zero velocity
	GVL.jogVelocity[18]:=0;
	GVL.jogVelocity[19]:=0;
	FOR i:=18 TO 19 DO
		gvl.jogButton[i]:=FALSE;
	END_FOR
	

END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_GripBall" Id="{1f01a78d-0e9a-4c59-b6b3-08a081060644}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_GripBall : BOOL
VAR_INPUT
END_VAR
VAR
	leg_target_joint_angle:ARRAY[0..1,0..2] OF LREAL:=[-pi/2,168*pi/180,(350-168)*pi/180,
                                                       pi/2,168*pi/180,(350-168)*pi/180];
	tr: LREAL;
	i: INT;
	Rb_target1: Mat3;
	noMotion: INT;
	j: INT;
	temp:vec3;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i:=0 TO 1 DO
	IF GripBallSubState[i]=FALSE AND isStone(i+2) THEN
		GripBallSubState[i]:=TRUE;
		leg_ref_pos_enter[i+2]:=leg_ref_pos[i];
	END_IF
END_FOR

FOR i:=0 TO 1 DO
	body_ref_pos:=body_ref_pos_enter;
	body_ref_ang:=body_ref_ang_enter;
	leg_ref_pos:=leg_ref_pos_enter;
	IF (gait_cycle-EnterGripBallCount)<=GripBallTime*gvl.sampleRate THEN
		IF GripBallSubState[i]=FALSE THEN
			tr  := UDINT_TO_LREAL(gait_cycle - EnterGripBallCount) / gvl.sampleRate / GripBallTime;
			fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
			FOR j:=0 TO 2 DO
				leg_grip_ball_joint_angle[i].data[j]:=(1-pvt)*leg_start_grip_ball_joint_angle[i].data[j]+pvt*leg_target_joint_angle[i,j];
			END_FOR
			gvl.legCtrl[i+2].ForwardKinetics(motorAngles:=leg_grip_ball_joint_angle[i].data , legIndex:=i+2 , tipPosition=>leg_grip_ball_pos_wrt_hip[i].data );
			fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
			temp.data[0]:=hip_pos[i+2,0];temp.data[1]:=hip_pos[i+2,1];temp.data[2]:=hip_pos[i+2,2];
			leg_ref_pos[i+2]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[i+2],leg_grip_ball_pos_wrt_hip[i]))),body_ref_pos);
		END_IF	
	END_IF
END_FOR

IF GripBallFinished=FALSE AND GripBallSubState[0]=TRUE AND GripBallSubState[1]=TRUE THEN
	GripBallFinished:=TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_LiftMleg" Id="{63bb683b-c404-48d4-98fe-765d2ddb6119}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_LiftMleg : BOOL
VAR_INPUT
END_VAR

VAR
	tr: LREAL;
	i: INT;
	j: INT;
	leg_target_joint_angle:ARRAY[0..1,0..2] OF LREAL:=[0,331.45*pi/180,(180-331.45)*pi/180,
                                                       0,331.45*pi/180,(180-331.45)*pi/180];
	Rb_target1: Mat3;
	temp:vec3;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF LiftMlegFinished:=FALSE AND (gait_cycle-EnterLiftMlegCount)<=LiftMlegTime*gvl.sampleRate THEN
	body_ref_pos:=body_ref_pos_enter;
	body_ref_ang:=body_ref_ang_enter;
	leg_ref_pos:=leg_ref_pos_enter;
	
	tr  := UDINT_TO_LREAL(gait_cycle - EnterLiftMlegCount) / gvl.sampleRate / LiftMlegTime;
	fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			leg_lift_Mleg_joint_angle[i].data[j]:=(1-pvt)*leg_start_lift_Mleg_joint_angle[i].data[j]+pvt*leg_target_joint_angle[i,j];
		END_FOR
		gvl.legCtrl[LegMapping14[i]].ForwardKinetics(motorAngles:=leg_lift_Mleg_joint_angle[i].data , legIndex:=LegMapping14[i] , tipPosition=>leg_lift_Mleg_pos_wrt_hip[i].data );
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping14[i],0];temp.data[1]:=hip_pos[LegMapping14[i],1];temp.data[2]:=hip_pos[LegMapping14[i],2];
		leg_ref_pos[LegMapping14[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping14[i]],leg_lift_Mleg_pos_wrt_hip[i]))),body_ref_pos);
	END_FOR
ELSE
	LiftMlegFinished:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_PushReleaseBall" Id="{46b2c2f9-d409-4dd4-9498-2d0562c8b840}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_PushReleaseBall : BOOL
VAR_INPUT
END_VAR
VAR
	leg_target_joint_angle:ARRAY[0..1,0..2] OF LREAL:=[-pi/2,160*pi/180,(355-160)*pi/180,
                                                       pi/2,160*pi/180,(355-160)*pi/180];
	tr: LREAL;
	i: INT;
	j: INT;
	Rb_target1: Mat3;
	temp:vec3;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF PushReleaseBallFinished=FALSE AND gait_cycle-EnterPushReleaseBallCount<=PushReleaseBallTime*gvl.sampleRate THEN
	body_ref_pos:=body_ref_pos_enter;
	body_ref_ang:=body_ref_ang_enter;
	leg_ref_pos:=leg_ref_pos_enter;
	tr  := UDINT_TO_LREAL(gait_cycle -EnterPushReleaseBallCount) / gvl.sampleRate / PushReleaseBallTime;
	fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
	
	FOR i:=0 TO 1 DO
		FOR j:=0 TO 2 DO
			FlegPushReleaseBall_joint_angle[i].data[j]:=(1-pvt)*FlegPushReleaseBall_start_joint_angle[i].data[j]+pvt*leg_target_joint_angle[i,j];
		END_FOR
		gvl.legCtrl[LegMapping23[i]].ForwardKinetics(motorAngles:=FlegPushReleaseBall_joint_angle[i].data , legIndex:=LegMapping23[i], tipPosition=>FlegPushReleaseBall_pos_wrt_hip[i].data );
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping23[i],0];temp.data[1]:=hip_pos[LegMapping23[i],1];temp.data[2]:=hip_pos[LegMapping23[i],2];
		leg_ref_pos[LegMapping23[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping23[i]],FlegPushReleaseBall_pos_wrt_hip[i]))),body_ref_pos);
	END_FOR

ELSE
	PushReleaseBallFinished:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_RecoveryReady" Id="{a2778230-d638-4020-bb93-6728e9d883dd}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_RecoveryReady : BOOL
VAR_INPUT
END_VAR
VAR
	tTotal: LREAL;
	tNow: LREAL;
	
	jntPosBegin : REFERENCE TO ARRAY[0..5, 0..2] OF LREAL;
	jntPosEnd   : REFERENCE TO ARRAY[0..5, 0..2] OF LREAL;
	jntAngRetract:ARRAY[0..5,0..2] OF LREAL:=[0,151.8713*pi/180,312.9916*pi/180,
											  0,332.3319*pi/180,(182.1891-332.3319)*pi/180,
											  0,332.3319*pi/180,(182.1891-332.3319)*pi/180,
											  0,332.3319*pi/180,(182.1891-332.3319)*pi/180,
											  0,332.3319*pi/180,(182.1891-332.3319)*pi/180,
											  0,151.8713*pi/180,312.9916*pi/180];
	jntAngExtend:ARRAY[0..5,0..2] OF LREAL:=[0,188.4468*pi/180,322.1064*pi/180,
											 0,312.3065*pi/180,(219.5084-312.3065)*pi/180,	
											 0,312.3065*pi/180,(219.5084-312.3065)*pi/180,
											 0,312.3065*pi/180,(219.5084-312.3065)*pi/180,
									         0,312.3065*pi/180,(219.5084-312.3065)*pi/180,
											 0,188.4468*pi/180,322.1064*pi/180];
											 
	i: INT;
	j: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF gait_cycle = 0 THEN
	RecoveryReadyFinished := FALSE;
	jntAngStart:=gvl.jntActualPos;
END_IF
IF gait_cycle<=(tRetract + tWait + tExtend) * gvl.sampleRate THEN //leg 0-2-4 recovery
	IF gait_cycle < tRetract * gvl.sampleRate THEN
		tTotal := tRetract;
		tNow   := UDINT_TO_LREAL(gait_cycle) * 1.0 / DINT_TO_LREAL(gvl.sampleRate);
		jntPosBegin REF= jntAngStart;
		FOR i:=0 TO 5 BY 2 DO
			FOR j:=0 TO 2 DO
				jntPosEnd[i,j]:=jntAngRetract[i,j];
				jntPosEnd[i+1,j]:=jntAngStart[i+1,j];
			END_FOR
		END_FOR
	ELSIF gait_cycle < (tRetract + tWait) * gvl.sampleRate THEN
		tTotal := tWait;
		tNow   := UDINT_TO_LREAL(gait_cycle) * 1.0 / DINT_TO_LREAL(gvl.sampleRate) - tRetract;
		FOR i:=0 TO 5 BY 2 DO
			FOR j:=0 TO 2 DO
				jntPosBegin[i,j]:=jntAngRetract[i,j];
				jntPosBegin[i+1,j]:=jntAngStart[i+1,j];
				jntPosEnd[i,j]:=jntAngRetract[i,j];
				jntPosEnd[i+1,j]:=jntAngStart[i+1,j];
			END_FOR
		END_FOR
	ELSE 
		tTotal := tExtend;
		tNow   := UDINT_TO_LREAL(gait_cycle) * 1.0 / DINT_TO_LREAL(gvl.sampleRate) - tRetract - tWait;
		FOR i:=0 TO 5 BY 2 DO
			FOR j:=0 TO 2 DO
				jntPosBegin[i,j]:=jntAngRetract[i,j];
				jntPosBegin[i+1,j]:=jntAngStart[i+1,j];
				jntPosEnd[i,j]:=jntAngExtend[i,j];
				jntPosEnd[i+1,j]:=jntAngStart[i+1,j];
			END_FOR
		END_FOR	
	END_IF	
ELSIF gait_cycle<=2*(tRetract + tWait + tExtend) * gvl.sampleRate  THEN //leg 1-3-5 recovery
	IF gait_cycle<=(2*tRetract + tWait + tExtend) * gvl.sampleRate THEN
		tTotal := tRetract;
		tNow   := UDINT_TO_LREAL(gait_cycle) * 1.0 / DINT_TO_LREAL(gvl.sampleRate)-(tRetract + tWait + tExtend);
		FOR i:=0 TO 5 BY 2 DO
			FOR j:=0 TO 2 DO
				jntPosBegin[i,j]:=jntAngExtend[i,j];
				jntPosBegin[i+1,j]:=jntAngStart[i+1,j];
				jntPosEnd[i,j]:=jntAngExtend[i,j];
				jntPosEnd[i+1,j]:=jntAngRetract[i+1,j];
			END_FOR
		END_FOR			
	ELSIF gait_cycle<=(2*tRetract + 2*tWait + tExtend) * gvl.sampleRate THEN
		tTotal := tWait;
		tNow   := UDINT_TO_LREAL(gait_cycle) * 1.0 / DINT_TO_LREAL(gvl.sampleRate) - (2*tRetract + tWait + tExtend);
		FOR i:=0 TO 5 BY 2 DO
			FOR j:=0 TO 2 DO
				jntPosBegin[i,j]:=jntAngExtend[i,j];
				jntPosBegin[i+1,j]:=jntAngRetract[i+1,j];
				jntPosEnd[i,j]:=jntAngExtend[i,j];
				jntPosEnd[i+1,j]:=jntAngRetract[i+1,j];
			END_FOR
		END_FOR			
	ELSE
		tTotal := tExtend;
		tNow   := UDINT_TO_LREAL(gait_cycle) * 1.0 / DINT_TO_LREAL(gvl.sampleRate) - (2*tRetract + 2*tWait + tExtend);
		FOR i:=0 TO 5 BY 2 DO
			FOR j:=0 TO 2 DO
				jntPosBegin[i,j]:=jntAngExtend[i,j];
				jntPosBegin[i+1,j]:=jntAngRetract[i+1,j];
				jntPosEnd[i,j]:=jntAngExtend[i,j];
				jntPosEnd[i+1,j]:=jntAngExtend[i+1,j];
			END_FOR
		END_FOR			
	END_IF
ELSE
	tTotal := 100;
	tNow   := UDINT_TO_LREAL(gait_cycle) * 1.0 / DINT_TO_LREAL(gvl.sampleRate) - 2*tRetract - 2*tWait - 2*tExtend;
	jntPosBegin REF=jntAngExtend;
	jntPosEnd REF=jntAngExtend;
END_IF

getPivot(tNow := tNow, tTotal := tTotal, pivot => pivot, pivotDot => pivotDot);
FOR i := 0 TO 5 DO
	FOR j := 0 TO 2 DO
		jointPosTarget[i, j] := (1.0 - pivot) * jntPosBegin[i, j] + pivot * jntPosEnd[i, j];
		jointVelTarget[i, j] := - pivotDot * jntPosBegin[i, j] + pivotDot * jntPosEnd[i, j];
		jointFceTarget[i, j] := 0;
	END_FOR
END_FOR
	
// exit condition
IF gait_cycle >= (2*tExtend + 2*tRetract + 2*tWait) * gvl.sampleRate + 3 THEN
	RecoveryReadyFinished := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_ReduceHeight" Id="{0e91e167-fb14-4d1a-a443-d91fdcdebde9}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_ReduceHeight : BOOL
VAR_INPUT
END_VAR

VAR
	tr: LREAL;
	i: INT;
	Rb_target1: Mat3;
	temp:vec3;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ReduceHeightFinished=FALSE AND (gait_cycle-EnterReduceHeightCount)<=ReduceHeightTime*gvl.sampleRate THEN

	body_ref_ang:=body_ref_ang_enter;
	leg_ref_pos:=leg_ref_pos_enter;
	
	tr  := UDINT_TO_LREAL(gait_cycle - EnterReduceHeightCount) / gvl.sampleRate / ReduceHeightTime;
	fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
	
	FOR i:=0 TO 2 DO
		body_ref_pos.data[i]:=(1-pvt)*body_ref_pos_enter.data[i]+pvt*body_target_pos.data[i];
	END_FOR
	gvl.legCtrl[2].ForwardKinetics(motorAngles:=leg2_start_reduce_height_joint_angle.data , legIndex:=2 , tipPosition=>leg2_start_reduce_height_pos_wrt_hip.data );
	gvl.legCtrl[3].ForwardKinetics(motorAngles:=leg3_start_reduce_height_joint_angle.data , legIndex:=3 , tipPosition=>leg3_start_reduce_height_pos_wrt_hip.data );
	
	fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm => Rb_target1 );
	temp.data[0]:=hip_pos[2,0];temp.data[1]:=hip_pos[2,1];temp.data[2]:=hip_pos[2,2];
	leg_ref_pos[2]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[2],leg2_start_reduce_height_pos_wrt_hip))),body_ref_pos);
	temp.data[0]:=hip_pos[3,0];temp.data[1]:=hip_pos[3,1];temp.data[2]:=hip_pos[3,2];
	leg_ref_pos[3]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[3],leg3_start_reduce_height_pos_wrt_hip))),body_ref_pos);
ELSE
	ReduceHeightFinished:=TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_SearchFootHold" Id="{01801426-ab7b-46a9-949f-4ba0cf8c6780}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_SearchFootHold : BOOL
VAR_INPUT
END_VAR
VAR
	body_ref_pos_start: Vec3;
	body_ref_ang_start:vec3;
	leg_ref_pos_start:ARRAY[0..5] OF Vec3;
	body_ref_pos_end: Vec3;
	body_ref_ang_end:vec3;
	leg_ref_pos_end:ARRAY[0..5] OF Vec3;
	i: INT;
	fbElipseInterpolation:ElipseInterpolation;
	fbHermitInterpolation:HermitInterpolation;
	tr: LREAL;
	j: INT;
	Rb_target1: Mat3;
	noMotion: INT;
	temp:vec3;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// substate machine for leg 0
IF SearchFootHoldSubState[0]= ReadySearchState AND requireLiftLegButton[0]=TRUE THEN
	SearchFootHoldSubState[0]:=LiftLegState;
	requireLiftLegButton[0]:=FALSE;
	EnterLiftLegStateCount[0]:=gait_cycle;
ELSIF SearchFootHoldSubState[0]=LiftLegState AND gait_cycle -EnterLiftLegStateCount[0]=lift_time*gvl.sampleRate THEN
	SearchFootHoldSubState[0]:=	SearchPedalState;
	EnterSearchPedalStateCount[0]:=gait_cycle;
	FOR j:=0 TO 2 DO
		tipSearchStartPosWrtHip[0].data[j]:=gvl.tipActualPos[0,j];
	END_FOR
	tipSearchEndPosWrtHip[0]:=tipSearchStartPosWrtHip[0];
	tipSearchEndPosWrtHip[0].data[0]:=tipSearchStartPosWrtHip[0].data[0]-search_distance;
ELSIF SearchFootHoldSubState[0]=SearchPedalState AND isPedal(0)=TRUE THEN 
	SearchFootHoldSubState[0]:=	DownLegState;
	EnterDownLegStateCount[0]:=gait_cycle;
	FOR j:=0 TO 2 DO
		tipDownLegStartPosWrtHip[0].data[j]:=gvl.tipActualPos[0,j];
	END_FOR
	tipDownLegEndPosWrtHip[0]:=tipDownLegStartPosWrtHip[0];
	tipDownLegEndPosWrtHip[0].data[1]:=tipDownLegStartPosWrtHip[0].data[1]-down_distance;
ELSIF SearchFootHoldSubState[0]=DownLegState AND  gait_cycle -EnterDownLegStateCount[0]=down_time*gvl.sampleRate THEN
	SearchFootHoldSubState[0]:=	PreSearchedState;
	EnterPreSearchedStateCount[0]:=gait_cycle;
ELSIF SearchFootHoldSubState[0]=PreSearchedState AND  gait_cycle -EnterPreSearchedStateCount[0]= holdTime*gvl.sampleRate THEN
	SearchFootHoldSubState[0]:=SearchedState;
	EnterSearchedStateCount[0]:=gait_cycle;
END_IF

IF SearchFootHoldFinished=FALSE AND SearchFootHoldSubState[0]=SearchedState AND SearchFootHoldSubState[1]=SearchedState THEN
	SearchFootHoldFinished:=TRUE;
END_IF

// trjPlanning for leg 0
IF SearchFootHoldSubState[0]=LiftLegState THEN
	IF gait_cycle -EnterLiftLegStateCount[0]<=lift_time*gvl.sampleRate THEN
		leg_ref_pos_start:=leg_ref_pos_enter;
		leg_ref_pos_end:=leg_ref_pos_enter;
		leg_ref_pos_end[0].data[2]:=leg_ref_pos_enter[0].data[2]+lift_distance;
		
		leg_ref_pos:=leg_ref_pos_enter;
		tr  := UDINT_TO_LREAL(gait_cycle - EnterLiftLegStateCount[0]) / gvl.sampleRate / lift_time;
		fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
		leg_ref_pos[0].data[2]:=(1-pvt)*leg_ref_pos_start[0].data[2]+pvt*leg_ref_pos_end[0].data[2];
		
		body_ref_pos:=body_ref_pos_enter;
		body_ref_ang:=body_ref_ang_enter;
	END_IF
ELSIF SearchFootHoldSubState[0]=SearchPedalState THEN
	IF gait_cycle -EnterSearchPedalStateCount[0]<=search_time*gvl.sampleRate THEN
		body_ref_pos:=body_ref_pos_enter;
		body_ref_ang:=body_ref_ang_enter;
		leg_ref_pos:=leg_ref_pos_enter;
		
		tr  := UDINT_TO_LREAL(gait_cycle - EnterSearchPedalStateCount[0]) / gvl.sampleRate / search_time;
		fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
		tipSearchPosWrtHip[0].data[0]:=(1-pvt)*tipSearchStartPosWrtHip[0].data[0]+pvt*tipSearchEndPosWrtHip[0].data[0];
		tipSearchPosWrtHip[0].data[1]:=tipSearchStartPosWrtHip[0].data[1];
		tipSearchPosWrtHip[0].data[2]:=tipSearchStartPosWrtHip[0].data[2];
		
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[0,0];temp.data[1]:=hip_pos[0,1];temp.data[2]:=hip_pos[0,2];
		leg_ref_pos[0]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[0],tipSearchPosWrtHip[0]))),body_ref_pos);
	END_IF
ELSIF SearchFootHoldSubState[0]=DownLegState THEN
	IF gait_cycle -EnterDownLegStateCount[0]<=down_time*gvl.sampleRate THEN
		body_ref_pos:=body_ref_pos_enter;
		body_ref_ang:=body_ref_ang_enter;
		leg_ref_pos:=leg_ref_pos_enter;
		
		tr  := UDINT_TO_LREAL(gait_cycle - EnterDownLegStateCount[0]) / gvl.sampleRate / down_time;
		fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
		tipDownLegPosWrtHip[0].data[0]:=tipDownLegStartPosWrtHip[0].data[0];
		tipDownLegPosWrtHip[0].data[1]:=(1-pvt)*tipDownLegStartPosWrtHip[0].data[1]+pvt*tipDownLegEndPosWrtHip[0].data[1];
		tipDownLegPosWrtHip[0].data[0]:=tipDownLegStartPosWrtHip[0].data[2];
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[0,0];temp.data[1]:=hip_pos[0,1];temp.data[2]:=hip_pos[0,2];
		leg_ref_pos[0]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[0],tipDownLegPosWrtHip[0]))),body_ref_pos);
	ELSE
		noMotion:=1;
	END_IF
END_IF

// substate machine for leg 5
IF SearchFootHoldSubState[0]=SearchedState THEN
IF SearchFootHoldSubState[1]= ReadySearchState AND requireLiftLegButton[1]=TRUE THEN
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;

	SearchFootHoldSubState[1]:=LiftLegState;
	requireLiftLegButton[1]:=FALSE;
	EnterLiftLegStateCount[1]:=gait_cycle;
ELSIF SearchFootHoldSubState[1]=LiftLegState AND gait_cycle -EnterLiftLegStateCount[1]=lift_time*gvl.sampleRate THEN
	SearchFootHoldSubState[1]:=	SearchPedalState;
	EnterSearchPedalStateCount[1]:=gait_cycle;
	FOR j:=0 TO 2 DO
		tipSearchStartPosWrtHip[1].data[j]:=gvl.tipActualPos[5,j];
	END_FOR
	tipSearchEndPosWrtHip[1]:=tipSearchStartPosWrtHip[1];
	tipSearchEndPosWrtHip[1].data[0]:=tipSearchStartPosWrtHip[1].data[0]-search_distance;
ELSIF SearchFootHoldSubState[1]=SearchPedalState AND isPedal(5)=TRUE THEN 
	SearchFootHoldSubState[1]:=	DownLegState;
	EnterDownLegStateCount[1]:=gait_cycle;
	FOR j:=0 TO 2 DO
		tipDownLegStartPosWrtHip[1].data[j]:=gvl.tipActualPos[5,j];
	END_FOR
	tipDownLegEndPosWrtHip[1]:=tipDownLegStartPosWrtHip[1];
	tipDownLegEndPosWrtHip[1].data[1]:=tipDownLegStartPosWrtHip[1].data[1]-down_distance;
ELSIF SearchFootHoldSubState[1]=DownLegState AND  gait_cycle -EnterDownLegStateCount[1]=down_time*gvl.sampleRate THEN
	SearchFootHoldSubState[1]:=	PreSearchedState;
	EnterPreSearchedStateCount[1]:=gait_cycle;
ELSIF SearchFootHoldSubState[1]=PreSearchedState AND  gait_cycle -EnterPreSearchedStateCount[1]= holdTime*gvl.sampleRate THEN
	SearchFootHoldSubState[1]:=SearchedState;
	EnterSearchedStateCount[1]:=gait_cycle;
END_IF

// trjPlanning for leg 5
IF SearchFootHoldSubState[1]=LiftLegState THEN
	IF gait_cycle -EnterLiftLegStateCount[1]<=lift_time*gvl.sampleRate THEN
		leg_ref_pos_start:=leg_ref_pos_enter;
		leg_ref_pos_end:=leg_ref_pos_enter;
		leg_ref_pos_end[5].data[2]:=leg_ref_pos_enter[5].data[2]+lift_distance;
		
		leg_ref_pos:=leg_ref_pos_enter;
		tr  := UDINT_TO_LREAL(gait_cycle - EnterLiftLegStateCount[1]) / gvl.sampleRate / lift_time;
		fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
		leg_ref_pos[5].data[2]:=(1-pvt)*leg_ref_pos_start[5].data[2]+pvt*leg_ref_pos_end[5].data[2];
		
		body_ref_pos:=body_ref_pos_enter;
		body_ref_ang:=body_ref_ang_enter;
	END_IF
ELSIF SearchFootHoldSubState[1]=SearchPedalState THEN
	IF gait_cycle -EnterSearchPedalStateCount[1]<=search_time*gvl.sampleRate THEN
		body_ref_pos:=body_ref_pos_enter;
		body_ref_ang:=body_ref_ang_enter;
		leg_ref_pos:=leg_ref_pos_enter;
		
		tr  := UDINT_TO_LREAL(gait_cycle - EnterSearchPedalStateCount[1]) / gvl.sampleRate / search_time;
		fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
		tipSearchPosWrtHip[1].data[0]:=(1-pvt)*tipSearchStartPosWrtHip[1].data[0]+pvt*tipSearchEndPosWrtHip[1].data[0];
		tipSearchPosWrtHip[1].data[1]:=tipSearchStartPosWrtHip[1].data[1];
		tipSearchPosWrtHip[1].data[2]:=tipSearchStartPosWrtHip[1].data[2];
		
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[5,0];temp.data[1]:=hip_pos[5,1];temp.data[2]:=hip_pos[5,2];
		leg_ref_pos[5]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[5],tipSearchPosWrtHip[1]))),body_ref_pos);
	END_IF
ELSIF SearchFootHoldSubState[1]=DownLegState THEN
	IF gait_cycle -EnterDownLegStateCount[1]<=down_time*gvl.sampleRate THEN
		body_ref_pos:=body_ref_pos_enter;
		body_ref_ang:=body_ref_ang_enter;
		leg_ref_pos:=leg_ref_pos_enter;
		
		tr  := UDINT_TO_LREAL(gait_cycle - EnterDownLegStateCount[1]) / gvl.sampleRate / down_time;
		fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
		tipDownLegPosWrtHip[1].data[0]:=tipDownLegStartPosWrtHip[1].data[0];
		tipDownLegPosWrtHip[1].data[1]:=(1-pvt)*tipDownLegStartPosWrtHip[1].data[1]+pvt*tipDownLegEndPosWrtHip[1].data[1];
		tipDownLegPosWrtHip[1].data[0]:=tipDownLegStartPosWrtHip[1].data[2];
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[5,0];temp.data[1]:=hip_pos[5,1];temp.data[2]:=hip_pos[5,2];
		leg_ref_pos[5]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[5],tipDownLegPosWrtHip[1]))),body_ref_pos);
	ELSE
		noMotion:=1;
	END_IF
END_IF

END_IF






















]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_Slide" Id="{7d3bb6e1-b2c7-4e65-bd66-6a02b4acc397}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_Slide : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[body_ref_pos:=body_ref_pos_enter;
body_ref_ang:=body_ref_ang_enter;
leg_ref_pos:=leg_ref_pos_enter;

IF ReleaseBallPositionReached=FALSE AND gait_cycle-EnterSlideCount>=SlideTime THEN
	ReleaseBallPositionReached:=TRUE;
END_IF

IF SlideFinished=FALSE AND ReleaseBallPositionReached=TRUE THEN
	SlideFinished:=true;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_SpeedDown" Id="{5b2a8cf9-1cbf-415b-9e9a-0a253aa7372d}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_SpeedDown : BOOL
VAR_INPUT
END_VAR
VAR
	i: INT;
	leg_target_joint_angle:ARRAY[0..1,0..2] OF LREAL:=[0,331.45*pi/180,-142.5*pi/180,
                                                       0,331.45*pi/180,-142.5*pi/180];
	tr: LREAL;
	j: INT;
	Rb_target1: Mat3;
	temp:vec3;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR i:=0 TO 1 DO
	IF Mleg_speed_down_finished[i]=FALSE AND isGrounded( LegMapping14[i]) THEN
		Mleg_speed_down_finished[i]:=TRUE;
		body_ref_pos_enter :=body_ref_pos;
		body_ref_ang_enter:=body_ref_ang;
		leg_ref_pos_enter := leg_ref_pos;
	END_IF
	IF Bleg_speed_down_finished[i]=FALSE AND isGrounded( LegMapping05[i]) THEN
		Bleg_speed_down_finished[i]:=TRUE;
		body_ref_pos_enter :=body_ref_pos;
		body_ref_ang_enter:=body_ref_ang;
		leg_ref_pos_enter := leg_ref_pos;
	END_IF
END_FOR
IF visual_tested_velocity=0 AND Mleg_speed_down_finished[0]=TRUE AND Mleg_speed_down_finished[1]=TRUE AND
	Bleg_speed_down_finished[0]=TRUE AND Bleg_speed_down_finished[1]=TRUE THEN
	SpeedDownFinished:=TRUE;
END_IF

body_ref_pos:=body_ref_pos_enter;
body_ref_ang:=body_ref_ang_enter;
leg_ref_pos:=leg_ref_pos_enter;
FOR i:=0 TO 1 DO
	tr  := UDINT_TO_LREAL(gait_cycle - EnterSpeedDownCount) / gvl.sampleRate / SpeedDownTime;
	fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
	IF Mleg_speed_down_finished[i]=FALSE AND gait_cycle-EnterSpeedDownCount<=SpeedDownTime  THEN
		FOR j:=0 TO 2 DO
			Mleg_speed_down_joint_angle[i].data[j]:=(1-pvt)*Mleg_speed_down_start_joint_angle[i].data[j]+pvt*leg_target_joint_angle[i,j];
		END_FOR
		gvl.legCtrl[LegMapping14[i]].ForwardKinetics(motorAngles:=Mleg_speed_down_joint_angle[i].data , legIndex:=LegMapping14[i] , tipPosition=>Mleg_speed_down_pos_wrt_hip[i].data );
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping14[i],0];temp.data[1]:=hip_pos[LegMapping14[i],1];temp.data[2]:=hip_pos[LegMapping14[i],2];
		leg_ref_pos[LegMapping14[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping14[i]],Mleg_speed_down_pos_wrt_hip[i]))),body_ref_pos);
	END_IF
	IF Bleg_speed_down_finished[i]=FALSE AND gait_cycle-EnterSpeedDownCount<=SpeedDownTime  THEN
		Bleg_speed_down_pos_wrt_hip[i]:=Bleg_speed_down_start_pos_wrt_hip[i];
		Bleg_speed_down_pos_wrt_hip[i].data[1]:=(1-pvt)*Bleg_speed_down_start_pos_wrt_hip[i].data[1]+pvt*(Bleg_speed_down_start_pos_wrt_hip[i].data[1]-Distance_y_DS-0.01);
				
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping05[i],0];temp.data[1]:=hip_pos[LegMapping05[i],1];temp.data[2]:=hip_pos[LegMapping05[i],2];
		leg_ref_pos[LegMapping05[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping05[i]],Bleg_speed_down_pos_wrt_hip[i]))),body_ref_pos);	
	END_IF
END_FOR

]]></ST>
      </Implementation>
    </Method>
    <Method Name="TrjPlanning_SpeedUp" Id="{ca331d3a-4eca-480d-addc-af3c2ba73cb0}">
      <Declaration><![CDATA[METHOD PUBLIC TrjPlanning_SpeedUp : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	invalid: LREAL;
	Rb_target1: Mat3;
	temp:vec3;
	tr: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF SpeedUpSubState=SpeedUpAS AND gait_cycle-EnterSpeedUpASCount=Time_AS*gvl.sampleRate THEN
	SpeedUpSubState:=SpeedUpCS;
	EnterSpeedUpCSCount:=gait_cycle;
	leg_speed_up_start_pos_wrt_hip:=leg_speed_up_pos_wrt_hip;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
	
ELSIF SpeedUpSubState=SpeedUpCS AND gait_cycle-EnterSpeedUpCSCount=Time_CS*gvl.sampleRate THEN
	SpeedUpSubState:=SpeedUpDS;
	EnterSpeedUpDSCount:=gait_cycle;
	leg_speed_up_start_pos_wrt_hip:=leg_speed_up_pos_wrt_hip;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
ELSIF SpeedUpSubState=SpeedUpDS AND gait_cycle-EnterSpeedUpDSCount=Time_DS*gvl.sampleRate THEN
	SpeedUpSubState:=SpeedUpSS;
	EnterSpeedUpSPCount:=gait_cycle;
	body_ref_pos_enter :=body_ref_pos;
	body_ref_ang_enter:=body_ref_ang;
	leg_ref_pos_enter := leg_ref_pos;
END_IF

body_ref_pos:=body_ref_pos_enter;
body_ref_ang:=body_ref_ang_enter;
leg_ref_pos:=leg_ref_pos_enter;
IF SpeedUpSubState=SpeedUpAS AND gait_cycle-EnterSpeedUpASCount<=Time_AS*gvl.sampleRate THEN
	FOR i:=0 TO 1 DO
		fbHermitInterpolation(t0:=EnterSpeedUpASCount*delta_t , T:=Time_AS , y0:=leg_speed_up_start_pos_wrt_hip[i].data[0] , 
		y1:=leg_speed_up_start_pos_wrt_hip[i].data[0]-Distance_x_AS , v0:=0 , v1:=-target_vel , tNow:=(gait_cycle-EnterSpeedUpASCount)* delta_t, 
		y=> leg_speed_up_pos_wrt_hip[i].data[0], v=>invalid );
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping05[i],0];temp.data[1]:=hip_pos[LegMapping05[i],1];temp.data[2]:=hip_pos[LegMapping05[i],2];
		leg_ref_pos[LegMapping05[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping05[i]],leg_speed_up_pos_wrt_hip[i]))),body_ref_pos);
	END_FOR
END_IF

IF SpeedUpSubState=SpeedUpCS AND gait_cycle-EnterSpeedUpCSCount<=Time_CS*gvl.sampleRate THEN
	FOR i:=0 TO 1 DO
		leg_speed_up_pos_wrt_hip[i]:=leg_speed_up_start_pos_wrt_hip[i];
		fbHermitInterpolation(t0:=EnterSpeedUpCSCount*delta_t , T:=Time_CS , y0:=leg_speed_up_start_pos_wrt_hip[i].data[0] , 
		y1:=leg_speed_up_start_pos_wrt_hip[i].data[0]-target_vel*Time_CS , v0:=-target_vel , v1:=-target_vel , tNow:=(gait_cycle-EnterSpeedUpCSCount)* delta_t, 
		y=> leg_speed_up_pos_wrt_hip[i].data[0], v=>invalid );
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping05[i],0];temp.data[1]:=hip_pos[LegMapping05[i],1];temp.data[2]:=hip_pos[LegMapping05[i],2];
		leg_ref_pos[LegMapping05[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping05[i]],leg_speed_up_pos_wrt_hip[i]))),body_ref_pos);
	END_FOR	
END_IF

IF SpeedUpSubState=SpeedUpDS AND gait_cycle-EnterSpeedUpDSCount<=Time_DS*gvl.sampleRate THEN
	FOR i:=0 TO 1 DO
		leg_speed_up_pos_wrt_hip[i]:=leg_speed_up_start_pos_wrt_hip[i];
		fbHermitInterpolation(t0:=EnterSpeedUpDSCount*delta_t , T:=Time_DS , y0:=leg_speed_up_start_pos_wrt_hip[i].data[0] , 
		y1:=leg_speed_up_start_pos_wrt_hip[i].data[0]-Distance_x_DS , v0:=-target_vel , v1:=0 , tNow:=(gait_cycle-EnterSpeedUpDSCount)* delta_t, 
		y=> leg_speed_up_pos_wrt_hip[i].data[0], v=>invalid );
		
		tr  := UDINT_TO_LREAL(gait_cycle - EnterSpeedUpDSCount) / gvl.sampleRate / Time_DS;
		fbGetPivot(tNow := tr, tTotal := 1.0, pivot => pvt);
		leg_speed_up_pos_wrt_hip[i].data[1]:=(1-pvt)*leg_speed_up_start_pos_wrt_hip[i].data[1]+pvt*(leg_speed_up_start_pos_wrt_hip[i].data[1]+Distance_y_DS);
		
		fbRotMat(yaw := body_ref_ang_enter.data[2], pitch := body_ref_ang_enter.data[1],roll := body_ref_ang_enter.data[0], rm =>  Rb_target1 );
		temp.data[0]:=hip_pos[LegMapping05[i],0];temp.data[1]:=hip_pos[LegMapping05[i],1];temp.data[2]:=hip_pos[LegMapping05[i],2];
		leg_ref_pos[LegMapping05[i]]:= VecAdd( MatMulVec(Rb_target1, VecAdd(temp,MatMulVec(Rleg[LegMapping05[i]],leg_speed_up_pos_wrt_hip[i]))),body_ref_pos);		
	END_FOR
END_IF

IF SpeedUpFinished=FALSE AND SpeedUpSubState= SpeedUpSS THEN
	SpeedUpFinished:=TRUE;
END_IF













]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="CurlingGait">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.DoPlanning">
      <LineId Id="45" Count="3" />
      <LineId Id="50" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.Initialize">
      <LineId Id="123" Count="4" />
      <LineId Id="8" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="244" Count="0" />
      <LineId Id="166" Count="1" />
      <LineId Id="170" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="187" Count="1" />
      <LineId Id="206" Count="0" />
      <LineId Id="208" Count="5" />
      <LineId Id="207" Count="0" />
      <LineId Id="229" Count="1" />
      <LineId Id="232" Count="11" />
      <LineId Id="168" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="164" Count="0" />
      <LineId Id="160" Count="0" />
      <LineId Id="171" Count="1" />
      <LineId Id="202" Count="0" />
      <LineId Id="204" Count="1" />
      <LineId Id="22" Count="2" />
      <LineId Id="28" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="30" Count="21" />
      <LineId Id="88" Count="3" />
      <LineId Id="87" Count="0" />
      <LineId Id="64" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.isGrounded">
      <LineId Id="6" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.isPedal">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="9" Count="1" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.isStone">
      <LineId Id="7" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.SetTargetValue">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="1" />
    </LineIds>
    <LineIds Name="CurlingGait.StateMachine">
      <LineId Id="20" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="29" Count="3" />
      <LineId Id="34" Count="8" />
      <LineId Id="33" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="46" Count="2" />
      <LineId Id="45" Count="0" />
      <LineId Id="52" Count="1" />
      <LineId Id="58" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="75" Count="1" />
      <LineId Id="78" Count="2" />
      <LineId Id="77" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="92" Count="2" />
      <LineId Id="86" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="95" Count="1" />
      <LineId Id="98" Count="2" />
      <LineId Id="97" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="113" Count="1" />
      <LineId Id="111" Count="1" />
      <LineId Id="117" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="120" Count="1" />
      <LineId Id="119" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="124" Count="3" />
      <LineId Id="123" Count="0" />
      <LineId Id="129" Count="5" />
      <LineId Id="81" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="138" Count="2" />
      <LineId Id="137" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="142" Count="0" />
      <LineId Id="149" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="150" Count="0" />
      <LineId Id="152" Count="1" />
      <LineId Id="151" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="157" Count="4" />
      <LineId Id="156" Count="0" />
      <LineId Id="219" Count="0" />
      <LineId Id="222" Count="0" />
      <LineId Id="225" Count="0" />
      <LineId Id="224" Count="0" />
      <LineId Id="226" Count="0" />
      <LineId Id="220" Count="1" />
      <LineId Id="162" Count="5" />
      <LineId Id="143" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="183" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="185" Count="0" />
      <LineId Id="184" Count="0" />
      <LineId Id="186" Count="0" />
      <LineId Id="182" Count="0" />
      <LineId Id="187" Count="1" />
      <LineId Id="170" Count="1" />
      <LineId Id="190" Count="2" />
      <LineId Id="189" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="193" Count="1" />
      <LineId Id="169" Count="0" />
      <LineId Id="195" Count="2" />
      <LineId Id="144" Count="0" />
      <LineId Id="198" Count="2" />
      <LineId Id="202" Count="1" />
      <LineId Id="201" Count="0" />
      <LineId Id="204" Count="1" />
      <LineId Id="207" Count="0" />
      <LineId Id="209" Count="1" />
      <LineId Id="208" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="61" Count="13" />
      <LineId Id="60" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning">
      <LineId Id="141" Count="0" />
      <LineId Id="224" Count="0" />
      <LineId Id="226" Count="0" />
      <LineId Id="323" Count="0" />
      <LineId Id="352" Count="0" />
      <LineId Id="325" Count="0" />
      <LineId Id="379" Count="5" />
      <LineId Id="411" Count="4" />
      <LineId Id="417" Count="1" />
      <LineId Id="416" Count="0" />
      <LineId Id="419" Count="0" />
      <LineId Id="421" Count="5" />
      <LineId Id="420" Count="0" />
      <LineId Id="324" Count="0" />
      <LineId Id="77" Count="37" />
      <LineId Id="186" Count="1" />
      <LineId Id="115" Count="3" />
      <LineId Id="188" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="119" Count="2" />
      <LineId Id="123" Count="5" />
      <LineId Id="189" Count="0" />
      <LineId Id="453" Count="0" />
      <LineId Id="129" Count="5" />
      <LineId Id="5" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="167" Count="2" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_AddHeight">
      <LineId Id="5" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="21" Count="1" />
      <LineId Id="20" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_BodyRot">
      <LineId Id="31" Count="0" />
      <LineId Id="106" Count="1" />
      <LineId Id="109" Count="0" />
      <LineId Id="111" Count="1" />
      <LineId Id="110" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="120" Count="1" />
      <LineId Id="114" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="125" Count="1" />
      <LineId Id="124" Count="0" />
      <LineId Id="128" Count="2" />
      <LineId Id="127" Count="0" />
      <LineId Id="133" Count="11" />
      <LineId Id="132" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="147" Count="4" />
      <LineId Id="119" Count="0" />
      <LineId Id="154" Count="4" />
      <LineId Id="152" Count="0" />
      <LineId Id="160" Count="5" />
      <LineId Id="159" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="171" Count="0" />
      <LineId Id="168" Count="2" />
      <LineId Id="166" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="117" Count="1" />
      <LineId Id="115" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="198" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_FLegRot1">
      <LineId Id="5" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="23" Count="1" />
      <LineId Id="27" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="32" Count="1" />
      <LineId Id="35" Count="1" />
      <LineId Id="66" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="47" Count="1" />
      <LineId Id="51" Count="3" />
      <LineId Id="49" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_FLegRot2">
      <LineId Id="5" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="21" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="30" Count="1" />
      <LineId Id="33" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="38" Count="3" />
      <LineId Id="43" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_GripBall">
      <LineId Id="41" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="42" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="70" Count="1" />
      <LineId Id="69" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="56" Count="1" />
      <LineId Id="59" Count="0" />
      <LineId Id="62" Count="1" />
      <LineId Id="60" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="88" Count="1" />
      <LineId Id="14" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_LiftMleg">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="1" />
      <LineId Id="6" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="18" Count="1" />
      <LineId Id="23" Count="1" />
      <LineId Id="22" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_PushReleaseBall">
      <LineId Id="5" Count="0" />
      <LineId Id="32" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="22" Count="2" />
      <LineId Id="27" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="36" Count="1" />
      <LineId Id="34" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_RecoveryReady">
      <LineId Id="9" Count="91" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_ReduceHeight">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="1" />
      <LineId Id="6" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="21" Count="3" />
      <LineId Id="26" Count="3" />
      <LineId Id="41" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_SearchFootHold">
      <LineId Id="43" Count="0" />
      <LineId Id="47" Count="1" />
      <LineId Id="50" Count="1" />
      <LineId Id="57" Count="2" />
      <LineId Id="98" Count="3" />
      <LineId Id="97" Count="0" />
      <LineId Id="112" Count="0" />
      <LineId Id="114" Count="1" />
      <LineId Id="117" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="116" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="140" Count="2" />
      <LineId Id="144" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="275" Count="0" />
      <LineId Id="274" Count="0" />
      <LineId Id="276" Count="1" />
      <LineId Id="146" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="38" Count="1" />
      <LineId Id="41" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="88" Count="1" />
      <LineId Id="86" Count="0" />
      <LineId Id="103" Count="1" />
      <LineId Id="96" Count="0" />
      <LineId Id="105" Count="3" />
      <LineId Id="110" Count="0" />
      <LineId Id="250" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="120" Count="1" />
      <LineId Id="124" Count="1" />
      <LineId Id="122" Count="0" />
      <LineId Id="129" Count="1" />
      <LineId Id="134" Count="3" />
      <LineId Id="225" Count="0" />
      <LineId Id="252" Count="0" />
      <LineId Id="226" Count="0" />
      <LineId Id="126" Count="1" />
      <LineId Id="123" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="230" Count="1" />
      <LineId Id="227" Count="1" />
      <LineId Id="149" Count="24" />
      <LineId Id="63" Count="0" />
      <LineId Id="178" Count="28" />
      <LineId Id="253" Count="0" />
      <LineId Id="207" Count="12" />
      <LineId Id="223" Count="0" />
      <LineId Id="254" Count="0" />
      <LineId Id="224" Count="0" />
      <LineId Id="220" Count="2" />
      <LineId Id="176" Count="1" />
      <LineId Id="175" Count="0" />
      <LineId Id="64" Count="21" />
      <LineId Id="62" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_Slide">
      <LineId Id="6" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="1" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_SpeedDown">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="20" Count="0" />
      <LineId Id="17" Count="2" />
      <LineId Id="24" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="71" Count="1" />
      <LineId Id="75" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="27" Count="2" />
      <LineId Id="26" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="51" Count="1" />
      <LineId Id="49" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="65" Count="1" />
      <LineId Id="68" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="30" Count="0" />
    </LineIds>
    <LineIds Name="CurlingGait.TrjPlanning_SpeedUp">
      <LineId Id="5" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="78" Count="1" />
      <LineId Id="77" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="88" Count="0" />
      <LineId Id="81" Count="1" />
      <LineId Id="80" Count="0" />
      <LineId Id="13" Count="2" />
      <LineId Id="84" Count="1" />
      <LineId Id="83" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="20" Count="2" />
      <LineId Id="17" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="59" Count="1" />
      <LineId Id="58" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="71" Count="5" />
      <LineId Id="65" Count="1" />
      <LineId Id="87" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="95" Count="1" />
      <LineId Id="91" Count="0" />
      <LineId Id="97" Count="2" />
      <LineId Id="104" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="121" Count="1" />
      <LineId Id="25" Count="12" />
      <LineId Id="23" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>